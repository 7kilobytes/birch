#!/usr/bin/env bash
#
# birch - an IRC client written in pure bash.

setup_terminal() {
    printf '\e[?1049h\e[?25l\e[2J\e[1;%sr' "$((LINES-1))"
    stty -echo
}

reset_terminal() {
    printf '\e[2J\e[;r\e[?25h\e[?1049l'
    stty echo
}

get_term_size() {
    # In bash 4+, enabling 'checkwinsize' inside of a
    # script also sets the LINES and COLUMNS variables.
    # 'checkwinsize' updates the variables after a command,
    # so we run a command that does nothing.
    shopt -s checkwinsize; (:;:)
}

redraw() {
    # Clear the screen and print the last N lines of history.
    printf '\e[2J\e[1;%sr' "$((LINES-1))"
    printf '%s' "${hist[@]: -$((LINES-1))}"
}

setup_irc() {
    exec 69>&-
    exec 69<>"/dev/tcp/${host}/6667" || exit 1

    printf 'NICK %s\n' "$nick" >&69
    printf 'USER %s - - :%s\n' "$nick" "$nick" >&69
    printf 'PASS %s\n' "$pass" >&69
    printf 'JOIN %s\n' "$chan" >&69
}

print_msg() {
    # Nick color is based on nickname length. This is a cheap
    # way of coloring nicks differently without needing to keep
    # track of user+color.
    [[ $1 != "$nick" ]] &&
        local nick_color="\\e[38;5;${#1}m"

    printf -v msgs '\r\e[1m%b%s\e[m: %s\n' "$nick_color" "$1" "$2"
    printf '%s' "$msgs"
    hist+=("$msgs")
}

irc_receive() {
    read -srt 0.001 -u 69 &&
        case "$REPLY" in
            PING*)
                printf 'PONG %s\n' "${REPLY/PING }" >&69
            ;;

            ":"*"$host NICK"*)
                IFS=$' \r' read -r _ _ nick _ <<< "$REPLY"
            ;;

            :*"PRIVMSG $chan"*)
                IFS=' :!' read -r _ user _ _ _ mesg <<< "$REPLY"

                # Bold.
                mesg="${mesg/$'\00302\002'/$'\e[1m'}"
                mesg="${mesg/$'\003\002'/$'\e[m'}"

                print_msg "$user" "$mesg"
            ;;

            :*PRIVMSG*) ;;

            *)
                printf '%s\n' "${REPLY/*:}"
                hist+=("${REPLY/*:}"$'\n')
            ;;
        esac
}

irc_send() {
    printf '\e7\e[%sH\r\e[K%s\e[47m \e[m\e8' "$LINES" "$chan > $msg"

    IFS= read -rst 0.01 -n 1 &&
        case "$REPLY" in
            # Backspace.
            $'\177'|$'\b')
                msg="${msg%?}"
            ;;

            # Enter.
            "")
                irc_cmd "$msg"
                msg=
            ;;

            # If the input character is an escape, it's most likely
            # an escape sequence. The next 1-2 characters are most
            # likely '[' and '[A-Z]' and we need to ignore them.
            $'\e'*) esc=1 ;;

            # All other keys.
            [[:print:]])
                # Handle escape sequences (ignore them).
                ((esc == 1)) && {
                    [[ $REPLY == \[ ]] &&
                        return

                    esc=
                    return
                }

                msg+="$REPLY"
            ;;
        esac
}

irc_cmd() {
    case "$1" in
        '/join'*)
            # Instead of logging the messages for unfocused channels,
            # leave a channel before joining another one. This 'hack'
            # causes the IRC server to send us the latest messages.
            printf 'PART %s\n' "$chan" >&69
            printf 'JOIN %s\n' "${1/\/join }" >&69
            chan="$_"
        ;;

        '/nick'*)
            printf 'NICK %s\n' "${1/\/nick }" >&69
            nick="$_"
        ;;

        "") ;;

        *)
            printf 'PRIVMSG %s %s\n' "$chan" ":$1" >&69
            print_msg "$nick" "$1"
        ;;
    esac
}

get_args() {
    while getopts ":s:u:p:c:v" opt; do
        case "$opt" in
            's') host="$OPTARG" ;;
            'u') nick="$OPTARG" ;;
            'p') pass="$OPTARG" ;;
            'c') chan="$OPTARG" ;;
            '?') usage ;;

            v)
                printf '%s\n' "birch 0.0.1"
                exit
            ;;

            :)
                printf '%s\n' "Option -$OPTARG requires an argument." >&2
                exit 1
            ;;
        esac
    done

    [[ -z $host || -z $nick ]] &&
        usage
}

usage() {
    printf '%s\n\t%s\n\t%s\n\t%s\n\t%s\n' \
        "usage: [birch -s host -u nick [-p pass -c channel]]" \
        "-s server      Server to connect to (required)." \
        "-u nick        Username to use (required)." \
        "-p password    Password to use." \
        "-c channel     Channel to join."
    exit 1
}

main() {
    get_args "$@"

    # Leave the terminal in a useable state and close the connection on exit.
    trap 'reset_terminal; exec 69>&-' EXIT

    # SIGWINCH is asynchronous and causes issues during read loops.
    # Instead of doing anything we set a variable and handling the
    # resize synchronously after the server and input read time-out.
    trap 'resize=1' WINCH

    get_term_size
    setup_terminal
    setup_irc

    for ((;;)); {
        irc_send
        irc_receive

        # Make 'SIGWINCH' synchronous (see above trap).
        ((resize == 1)) && {
            get_term_size
            redraw
            resize=0
        }
    }
}

main "$@"
