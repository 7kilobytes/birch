#!/usr/bin/env bash
#
# birch - a simple irc client in bash

clean() {
    printf '\e[?7h\e[2J\e[;r\e[H\e[?1049l'
    rm -f -- "${TMPDIR:-/tmp}/birch-$$"*
    kill 0
}

refresh() {
    read -r h w < <(stty size)
    printf '\e[?1049h\e[?7l\e[2J\e[1;%sr\e[999H' "$((h-1))"
}

resize() {
    refresh

    printf '\e7\e[?25l\r\e[999B\e[A'

    fold -sw "$((w-12))" "${TMPDIR:-/tmp}/birch-$$" |
        sed '2,$s|^|            |g'

    printf '\e8\e[?25h%s\n\e[%sC' "$chan > " "$((${#chan}+3))"
}

connect() {
    exec 69<>"/dev/tcp/${s:=irc.freenode.net}/${P:-6667}" || {
        printf '%s\n' "error: Couldn't connect to $s." >&2
        exit 1
    }

    printf 'NICK %s\nUSER %s - - :%s\nPASS %s\nJOIN %s\n' \
       "${nick:=${u:-$USER}}" "$nick" "$nick" "${p-}" \
       "${chan:=${c:-#kisslinux}}" >&69
}

prin() {
    [[ $dest == \#* || $dest == \* || $dest == "$nick" ]] ||
        return

    raw=${1%% *}
    raw=${raw//$'\e[1;3'?m} 
    raw=${raw//$'\e[m'}

    printf -v out '\e[%sC%s' \
        "$((${#raw}>10?0:11-${#raw}))" "$1"

    printf '\e[?25l\e7\e[999B\e[A\r%s\n\r\e[2B%s\e8\e[?25h' \
        "$out" "$chan > " | 
        fold -sw "$((w-12))" | sed '2,$s|^|            |g'

    printf '\r%s\n' "$out" >> "${TMPDIR:-/tmp}/birch-$$"
}

cmd() {
    history -s "$1"
    read -ra cmd <<< "$1"

    send() { parse "$1"; printf '%s\n' "$1" >&69; }

    case $1 in ""|?/?*) ;;
        '/nick '*) send "NICK ${cmd[1]}"; nick=${cmd[1]} ;;
         '/msg '*) send "PRIVMSG ${cmd[1]} :${cmd[*]:2}" ;;
          '/me '*) send "PRIVMSG $chan :"$'\001'"ACTION ${cmd[*]:1}"$'\001' ;;
         '/quit'*) send "QUIT :${cmd[1]}"; clean ;;
               /*) send "NOTICE :${cmd[0]} not implemented yet" ;;
                *) send "PRIVMSG $chan :$1" ;;
    esac

    printf '\e[2K'
}

parse() {
    fields=() word='' from='' whom=''

    [[ "${1%% *}" == *[:@!]* ]] && {
        from=${1%% *}
        IFS='!@' read -r whom _ <<< "${from#:}"
    }

    while IFS= read -d '' -rn 1 c; do case $c in
        ' ') [[ $word ]] && fields+=("$word") word= ;;
          :) break ;;
          *) word+=$c ;;
    esac; done <<< "${1/"$from"}"

    whom=${whom:-${nick}}
    mesg=${1/"${from:+$from }${fields[*]} "} mesg=${mesg#:}
    dest=${fields[1]:-$chan}

    [[ $mesg == *$'\001ACTION'*$'\001'* ]] &&
        fields[0]=ACTION mesg=${mesg/$'\001ACTION' }
    
    nc=$'\e[1;3'$((${#whom}%6+1))m$whom$'\e[m'
    mc=$'\e[1;3'$((${#mesg}%6+1))m$mesg$'\e[m'
    dc=$'\e[1;3'$((${#dest}%6+1))m$dest$'\e[m'

    case ${fields[0]} in
        PRIVMSG) prin "${nc/$whom/${whom:0:10}} $mesg" ;;
         ACTION) prin "* $nc ${mesg/$'\001'}" ;;
         NOTICE) prin "NOTE $mesg" ;;
           QUIT) prin "<-- $nc has quit" ;;
           PART) prin "<-- $nc has left $dc" ;; 
           JOIN) prin "--> $nc has joined $dc" ;;
           NICK) prin "$nc is now known as $mc" ;; 
           PING) printf 'PONG%s\n' "${1##PING}" >&69 ;;
            376) cmd  "${x:-}" ;;
        ?[0-9]?) prin "${fields[0]} $mesg" ;;
              *) prin "RAW $mesg"  ;;
    esac
}

args() {
    while getopts :s:u:p:c:x:P:v opt; do case $opt in
        \?) printf 'birch [-s host -u nick -p pass -P port -c chan -x cmd]\n' ;;
         v) printf 'birch 0.0.1\n' ;;
         :) printf 'Option -%s requires an argument\n' "$OPTARG" >&2 ;;
         *) declare -g "$opt=$OPTARG" 
    esac; [[ $opt =~ \?|v|: ]] && exit; done
}

main() {
    args "$@"
    refresh
    connect

    export HISTFILE=${TMPDIR:=/tmp}/birch-$$-hist

    trap resize WINCH
    trap 'cmd /quit' INT

    while read -sru 69; do
        parse "${REPLY%%$'\r'*}" 
    done &
    
    while read -erp "$chan > "; do
        cmd "$REPLY"
    done
}

main "$@"
